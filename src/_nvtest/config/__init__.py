"""
Additional configuration is not required to run ``nvtest``.  To see the current
configuration, issue

.. code-block:: console

   nvtest config show

Configuration variables can be set on the command line or read from a
configuration file.

.. _config-file:

Configuration file
------------------

In addition to the command line, configuration variables can be explicitly set in:

- ``~/.nvtest``.
- ``./nvtest.cfg``

``~/.nvtest`` is the "global" configuration scope while ``./nvtest.cfg`` is the
"local" configuration scope.  The order of precedence for configuration scopes
is

1. Command line
2. Local configuration
3. Global configuration

.. note::

   There is also a "session" configuration scope that is written when a test
   session is created.  The values therein are set by the local configuration
   when the session is launched and take precedence in future invocations.

.. code-block:: ini

   [config]
   debug = false  # (bool)
   log_level = 2  # (int) [0, 4]
   test_files = r"^[a-zA-Z0-9_][a-zA-Z0-9_-]*\.(vvt|pyt)$" # regular expression for test file names

   [variables]
   var = value # (str) environment variables to set for the test session

   [machine]
   cores_per_socket = N  # (int) default computed from os.cpu_count()
   sockets_per_node = N  # (int) default: 1
   devices_per_socket = N  # (int)
   cpu_count = N  # (int) default computed from os.cpu_count()
   device_count = N  # (int) default computed from os.cpu_count()

  [build]
   type = ... # str
   date = ... # str

   [build:compiler]
   vendor = ... # str
   version = ... # str

   [build:compiler:paths]
   cc = ... # str
   cxx = ... # str
   fc = ... # str

   [build:options]
   opt = ... # str

.. note::

   The build configuration fields should be generated by :ref:`nvtest's CMake
   integration <howto-cmake-integration>`.

Setting configuration variables on the command line
---------------------------------------------------

Use yaml path syntax to set any of the above variables.  For example,

.. code-block:: console

   nvtest -c machine:cpu_count:20 -c config:log_level:0 SUBCOMMAND [OPTIONS] ARGUMENTS

To set environment variables do

.. code-block:: console

   nvtest -e VAR1=VAL1 -e VAR2=VAL2 SUBCOMMAND [OPTIONS] ARGUMENTS

"""

import argparse
import configparser
import copy
import json
import os
import sys
from string import Template
from typing import Any
from typing import Optional
from typing import TextIO
from typing import Union

from ..third_party.schema import Schema
from ..third_party.schema import SchemaError
from ..util import logging
from ..util import tty
from ..util.misc import ns2dict
from ..util.singleton import Singleton
from . import machine
from .schemas import any_schema
from .schemas import build_schema
from .schemas import config_schema
from .schemas import machine_schema
from .schemas import python_schema
from .schemas import variables_schema


class ConfigParser(configparser.ConfigParser):
    def optionxform(self, arg):
        return arg


config_dir = ".nvtest"


section_schemas: dict[str, Schema] = {
    "build": build_schema,
    "config": config_schema,
    "machine": machine_schema,
    "python": python_schema,
    "variables": variables_schema,
    "session": any_schema,
    "system": any_schema,
    "option": any_schema,
}

read_only_sections = ("python",)
valid_scopes = ("defaults", "global", "local", "session", "environment", "command_line")

invocation_dir = os.getcwd()


class Config:
    """Access to configuration values"""

    def __init__(self) -> None:
        static_machine_config = machine.machine_config()
        editable_machine_config = {
            key: static_machine_config.pop(key) for key in machine.editable_properties
        }
        self.scopes = {
            "defaults": {
                "config": {
                    "debug": False,
                    "log_level": 2,
                    "test_files": r"^[a-zA-Z0-9_][a-zA-Z0-9_-]*\.(vvt|pyt)$",
                },
                "machine": editable_machine_config,
                "system": static_machine_config,
                "variables": {},
                "python": {
                    "executable": sys.executable,
                    "version": ".".join(str(_) for _ in sys.version_info[:3]),
                    "version_info": list(sys.version_info),
                },
            }
        }
        self._cache: dict[tuple[str, Optional[str]], Any] = {}
        file = self.config_file("global")
        if file is not None and os.path.exists(file):
            self.load_config(file, "global")
        dir = os.getcwd()
        while dir != os.path.sep:
            path = os.path.join(dir, config_dir, "config")
            if os.path.exists(path):
                self.load_config(path, "session")
                self.set("session:work_tree", dir, scope="session")
                self.set("session:invocation_dir", invocation_dir, scope="session")
                start = os.path.relpath(dir, os.getcwd()) or "."
                self.set("session:start", start, scope="session")
                break
            dir = os.path.dirname(dir)
        else:
            file = self.config_file("local")
            if file is not None and os.path.exists(file):
                self.load_config(file, "local")
        self.load_env_config()

    def config_file(self, scope) -> Optional[str]:
        if scope == "global":
            if "NVTEST_GLOBAL_CONFIG" in os.environ:
                return os.environ["NVTEST_GLOBAL_CONFIG"]
            elif "HOME" in os.environ:
                home = os.environ["HOME"]
                return os.path.join(home, ".nvtest")
        elif scope == "local":
            return os.path.abspath("./nvtest.cfg")
        elif scope == "session":
            dir = self.get("session:work_tree")
            if not dir:
                raise ValueError("session:work_tree has not been set")
            return os.path.join(dir, config_dir, "config")
        return None

    def load_config(self, file: str, scope: str) -> None:
        self.scopes[scope] = read_config(file)
        if "variables" in self.scopes[scope]:
            for var, val in self.scopes[scope]["variables"].items():
                os.environ[var] = val

    def load_env_config(self) -> None:
        if "NVTEST_LOG_LEVEL" in os.environ:
            scope_data = self.scopes.setdefault("environment", {})
            level: int = tty.log_level_from_name(os.environ["NVTEST_LOG_LEVEL"])
            tty.set_log_level(level)
            scope_data.setdefault("config", {})["log_level"] = level
        if os.getenv("NVTEST_DEBUG", "off").lower() in ("on", "1", "true", "yes"):
            scope_data = self.scopes.setdefault("environment", {})
            scope_data.setdefault("config", {})["debug"] = True
            tty.set_debug(True)

    def dump(self, fh: TextIO, scope: Optional[str] = None):
        if scope is not None:
            merged = self.scopes[scope]
        else:
            merged = self.merge()
        table = self.flatten(merged)
        for section in sorted(table):
            fh.write(f"[{section}]\n")
            subsections: list[str] = []
            for key, value in table[section].items():
                if isinstance(value, dict):
                    subsections.append(key)
                else:
                    fh.write(f"{key} = {json.dumps(value)}\n")
            fh.write("\n")
            for subsection in subsections:
                fh.write(f"[{section}:{subsection}]\n")
                for key, value in table[section][subsection].items():
                    fh.write(f"{key} = {json.dumps(value)}\n")
                fh.write("\n")

    @staticmethod
    def flatten(mapping: dict) -> dict:
        fd = {}
        for s, sd in mapping.items():
            if not isinstance(sd, dict):
                fd[s] = sd
            else:
                for p, pd in sd.items():
                    if not isinstance(pd, dict):
                        fd.setdefault(s, {})[p] = pd
                    else:
                        fd[f"{s}:{p}"] = Config.flatten(pd)
        return fd

    def set_main_options(self, args: argparse.Namespace) -> None:
        scope_data = self.scopes.setdefault("command_line", {})
        if args.q or args.v:
            user_log_level = tty.default_log_level() - args.q + args.v
            level = max(min(user_log_level, tty.max_log_level()), tty.min_log_level())
            tty.set_log_level(level)
            scope_data.setdefault("config", {})["log_level"] = level
        if args.debug:
            tty.set_debug(True)
            scope_data.setdefault("config", {})["debug"] = True
        for var, val in args.env_mods.items():
            os.environ[var] = val
            scope_data.setdefault("variables", {})[var] = val
        for path in args.config_mods:
            self.add(path, scope="command_line")
        self.scopes["command_line"]["option"] = ns2dict(args)

    def merge(self, skip_scopes: Optional[list[str]] = None) -> dict:
        scopes = list(self.scopes.keys())
        merged = dict(self.scopes[scopes.pop(0)])
        for scope in scopes:
            if skip_scopes is not None and scope in skip_scopes:
                continue
            scope_data = dict(self.scopes[scope])
            merged = _merge(merged, scope_data)
        return merged

    def highest_precedence_scope(self) -> dict:
        scope = next(reversed(self.scopes.keys()))
        return self.scopes[scope]

    def validate_section_name(self, section: str) -> None:
        if section not in section_schemas:
            raise ValueError(f"{section!r} is not a valid configuration section")

    def validate_scope(self, scope: Union[str, None]) -> dict:
        if scope is None:
            return self.highest_precedence_scope()
        elif scope in self.scopes:
            return self.scopes[scope]
        elif scope in valid_scopes:
            return self.scopes.setdefault(scope, {})
        else:
            raise ValueError(f"{scope!r} is not a valid configuration scope")

    def get_config(self, section: str, scope: Optional[str] = None) -> dict:
        """Get configuration settings for a section.

        If ``scope`` is ``None`` or not provided, return the merged contents
        of all of nevada's configuration scopes.  If ``scope`` is provided,
        return only the configuration as specified in that scope.

        """
        self.validate_section_name(section)
        cfg_scopes: list[dict[str, Any]]
        cache_key = (section, scope)
        if cache_key in self._cache:
            return self._cache[cache_key]
        if scope is None:
            cfg_scopes = list(self.scopes.values())
        else:
            cfg_scopes = [self.validate_scope(scope)]
        merged: dict[str, Any] = {}
        for cfg_scope in cfg_scopes:
            data = cfg_scope.get(section)
            if not data or not isinstance(data, dict):
                continue
            merged = _merge(merged, {section: data})
        self._cache[cache_key] = {} if section not in merged else merged[section]
        return self._cache[cache_key]

    def get(self, path: str, default: Optional[Any] = None, scope: Optional[str] = None) -> Any:
        """Get a config section or a single value from one.

        Accepts a path syntax that allows us to grab nested config map
        entries.  Getting the 'config' section would look like::

            nvtest.config.get('config')

        and the ``debug`` section in the ``config`` scope would be::

            nvtest.config.get('config:debug')

        We use ``:`` as the separator, like YAML objects.
        """
        parts = parse_config_path(path)
        section = parts.pop(0)
        value = self.get_config(section, scope=scope)
        while parts:
            key = parts.pop(0)
            # cannot use value.get(key, default) in case there is another part
            # and default is not a dict
            if key not in value:
                return default
            value = value[key]
        return value

    def set(self, path: str, value: Any, scope: Optional[str] = None) -> None:
        """Convenience function for setting single config values

        Accepts the path syntax described in ``get()``.
        """

        if ":" not in path:
            # handle bare section name as path
            self.update_config(path, value, scope=scope)
            return

        parts = parse_config_path(path)
        section = parts.pop(0)
        if section in read_only_sections:
            raise ValueError(f"{section!r} is a read-only scope")
        self.validate_section_name(section)
        if section == "session":
            if scope is None:
                scope = "session"
            if scope != "session":
                raise ValueError("session section must set into session scope")
        section_data = self.get_config(section, scope=scope)
        data = section_data
        while len(parts) > 1:
            key = parts.pop(0)
            new = data[key]
            if isinstance(new, dict):
                new = dict(new)
                # reattach to parent object
                data[key] = new
            data = new
        # update new value
        data[parts[0]] = value
        self.update_config(section, section_data, scope=scope)

    def add(self, fullpath: str, scope: Optional[str] = None) -> None:
        """Add the given configuration to the specified config scope."""

        components = parse_config_path(fullpath)

        path = ""
        has_existing_value = True
        for idx, name in enumerate(components[:-1]):
            # First handle double colons in constructing path
            colon = ":" if path else ""
            path += colon + name

            # Test whether there is an existing value at this level
            existing = self.get(path, scope=scope)

            if existing is None:
                has_existing_value = False
                # construct value from this point down
                value = components[-1]
                try:
                    value = json.loads(value)
                except json.decoder.JSONDecodeError:
                    pass
                for component in reversed(components[idx + 1 : -1]):
                    value = {component: value}
                break

        if has_existing_value:
            path, _, value = fullpath.rpartition(":")
            value = json.loads(value)
            existing = self.get(path, scope=scope)

        # append values to lists
        if isinstance(existing, list) and not isinstance(value, list):
            value = [value]

        # merge value into existing
        new = _merge(existing, value)
        self.set(path, new, scope=scope)

    def invalidate_cache(self, section):
        keys = list(self._cache.keys())
        for key in keys:
            if key[0] == section:
                self._cache.pop(key)

    def update_config(self, section, update_data, scope=None):
        """Update the configuration file for a particular scope.

        Overwrites contents of a section in a scope with update_data,
        then writes out the config file.

        update_data should have the top-level section name stripped off
        (it will be re-added).  Data itself can be a list, dict, or any
        other yaml-ish structure.

        Configuration scopes that are still written in an old schema
        format will fail to update unless ``force`` is True.

        Args:
            section (str): section of the configuration to be updated
            update_data (dict): data to be used for the update
            scope (str): scope to be updated
        """
        self.validate_section_name(section)
        scope_data = self.validate_scope(scope)
        scope_data[section] = update_data
        self.invalidate_cache(section)

    def describe(self, section: Optional[str] = None) -> str:
        if section is not None:
            merged = {section: self.get_config(section)}
        else:
            merged = self.merge()
        try:
            import yaml

            return yaml.dump(merged, default_flow_style=False)
        except ImportError:
            return json.dumps(merged, indent=2)


def _merge(dest, source):
    """Merges source into dest; entries in source take precedence over dest.

    This routine may modify dest and should be assigned to dest, in
    case dest was None to begin with, e.g.:

       dest = merge(dest, source)

    In the result, elements from lists from ``source`` will appear before
    elements of lists from ``dest``. Likewise, when iterating over keys
    or items in merged ``OrderedDict`` objects, keys from ``source`` will
    appear before keys from ``dest``.

    Config file authors can optionally end any attribute in a dict
    with `::` instead of `:`, and the key will override that of the
    parent instead of merging.
    """

    def they_are(t):
        return isinstance(dest, t) and isinstance(source, t)

    # If source is None, overwrite with source.
    if source is None:
        return None

    # Source list is prepended (for precedence)
    if they_are(list):
        dest[:] = source + [x for x in dest if x not in source]
        return dest

    # Source dict is merged into dest.
    elif they_are(dict):
        # save dest keys to reinsert later -- this ensures that  source items
        # come *before* dest in OrderdDicts
        dest_keys = [dk for dk in dest.keys() if dk not in source]

        for sk, sv in source.items():
            # always remove the dest items. Python dicts do not overwrite
            # keys on insert, so this ensures that source keys are copied
            # into dest along with mark provenance (i.e., file/line info).
            merge_objects = sk in dest
            old_dest_value = dest.pop(sk, None)

            if merge_objects:
                dest[sk] = _merge(old_dest_value, sv)
            else:
                # if sk ended with ::, or if it's new, completely override
                dest[sk] = copy.deepcopy(sv)

        # reinsert dest keys so they are last in the result
        for dk in dest_keys:
            dest[dk] = dest.pop(dk)

        return dest

    # If we reach here source and dest are either different types or are
    # not both lists or dicts: replace with source.
    return copy.copy(source)


def safe_loads(arg):
    try:
        return json.loads(arg)
    except json.decoder.JSONDecodeError:
        return arg


def expandvars(arg: str, mapping: dict) -> str:
    t = Template(arg)
    return t.safe_substitute(mapping)


def read_config(file: str) -> dict:
    cfg = ConfigParser()
    cfg.read(file)
    data: dict[str, Any] = {}
    variables = dict(os.environ)
    # make variables available in other config sections
    if cfg.has_section("variables"):
        section_data = data.setdefault("variables", {})
        for key, raw_value in cfg.items("variables", raw=True):
            value = expandvars(raw_value, variables)
            section_data[key] = str(safe_loads(value))
            variables[key] = section_data[key]
    for section in cfg.sections():
        if section == "variables":
            continue
        section_data = data.setdefault(section, {})
        for key, raw_value in cfg.items(section, raw=True):
            value = expandvars(raw_value, variables)
            section_data[key] = safe_loads(value)
    config_data: dict[str, Any] = {}
    # expand any keys given as a:b:c
    for path, section_data in data.items():
        if path in section_schemas:
            config_data[path] = section_data
        elif ":" in path:
            parts = parse_config_path(path)
            if parts[0] not in section_schemas:
                logging.warning(f"ignoring unrecognized config section: {parts[0]}")
                continue
            x = config_data.setdefault(parts[0], {})
            for part in parts[1:]:
                x = x.setdefault(part, {})
            x.update(section_data)
        else:
            logging.warning(f"ignoring unrecognized config section: {path}")
    for section, section_data in config_data.items():
        schema = section_schemas[section]
        try:
            schema.validate({section: section_data})
        except SchemaError as e:
            raise ConfigSchemaError(file, e.args[0]) from None
    return config_data


def parse_config_path(path):
    """Parse the path argument to various configuration methods.
    Splits ``path`` on ':'

    """
    if path.startswith(":"):
        raise ValueError(f"Illegal leading `:' in path {path:r}")
    return [_.strip() for _ in path.split(":") if _.split()]


class IllegalConfiguration(Exception):
    def __init__(self, option, message=None):
        msg = f"Illegal configuration setting: {option}"
        if message:
            msg += f". {message}"
        super().__init__(msg)


class ConfigSchemaError(Exception):
    def __init__(self, filename, error):
        msg = f"Schema error encountered in {filename}: {error}"
        super().__init__(msg)


config = Singleton(Config)


def dump(fh: TextIO, scope: Optional[str] = None):
    return config.dump(fh, scope=scope)


def config_file(scope: str) -> Optional[str]:
    return config.config_file(scope)


def set_main_options(args: argparse.Namespace) -> None:
    return config.set_main_options(args)


def get(path: str, default: Optional[Any] = None, scope: Optional[str] = None) -> Any:
    return config.get(path, default=default, scope=scope)


def set(path: str, value: Any, scope: Optional[str] = None) -> None:
    return config.set(path, value, scope=scope)


def describe(section: Optional[str] = None) -> str:
    return config.describe(section=section)


def add(fullpath: str, scope: Optional[str] = None) -> None:
    config.add(fullpath, scope=scope)


def has_scope(scope: str) -> bool:
    return scope in config.scopes
